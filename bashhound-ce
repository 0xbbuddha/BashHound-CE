#!/usr/bin/env bash

################################################################################
# BashHound-CE - by 0xbbuddha
# 
# Active Directory data collector for BloodHound Community Edition (v6)
# Written in pure Bash - Alternative to SharpHound and RustHound
#
# This tool collects AD data via LDAP/LDAPS and exports it in BloodHound CE
# compatible JSON format. No external dependencies except standard Unix tools.
################################################################################

# Error handling disabled to allow the script to continue on LDAP errors
# Some LDAP queries may fail without breaking the entire collection
# set -euo pipefail
# set -u

# Script initialization - determine script location and load libraries
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/lib/ldap.sh"        # Core LDAP protocol implementation
source "$SCRIPT_DIR/lib/collectors.sh"  # AD object collectors (users, groups, etc.)
source "$SCRIPT_DIR/lib/export_ce.sh"   # BloodHound CE JSON export functions

# Global configuration variables
DOMAIN=""                  # Target AD domain (e.g., domain.local)
USERNAME=""                # Authentication username
PASSWORD=""                # Authentication password
LDAP_SERVER=""             # DC/LDAP server address
LDAP_PORT="389"            # LDAP port (389 for plain, 636 for TLS)
USE_LDAPS=false            # Whether to use LDAPS (TLS encryption)
OUTPUT_FILE=""             # Custom output filename (optional)
COLLECTION_METHOD="All"    # Collection method (All, DCOnly, Session, etc.)
ZIP_ONLY=false             # Delete JSON files after creating ZIP
VERBOSE=false              # Enable verbose/debug output

show_usage() {
    cat <<EOF
BashHound-CE - BloodHound Community Edition collector in pure Bash

Usage: $0 [options]

Options obligatoires:
    -d, --domain DOMAIN          Domaine Active Directory (ex: domain.local)
    -u, --user USERNAME          Nom d'utilisateur
    -p, --password PASSWORD      Mot de passe
    -s, --server SERVER          Serveur LDAP / Domain Controller

Options facultatives:
    -o, --output FILE            Fichier de sortie (défaut: bloodhound_TIMESTAMP.json)
    -c, --collection METHOD      Méthode de collection (défaut: All)
                                 Valeurs: All, DCOnly, Session, LoggedOn, Trusts, ACL, Group
    --zip-only                   Supprime les fichiers JSON après création du ZIP
    --port PORT                  Port LDAP (défaut: 389 pour LDAP, 636 pour LDAPS)
    --ldaps                      Utilise LDAPS (TLS) - équivalent à --port 636
    --no-tls                     Force LDAP sans TLS même sur port 636
    -v, --verbose                Mode verbeux (affiche tous les messages)
    -h, --help                   Affiche cette aide

Exemples:
    # LDAP standard (port 389)
    $0 -d domain.local -u administrator -p Password123 -s dc01.domain.local
    
    # LDAPS avec TLS (port 636)
    $0 -d domain.local -u administrator -p Password123 -s dc01.domain.local --ldaps
    $0 -d corp.local -u admin -p Pass123! -s 192.168.1.10 --port 636
    
    # Avec options avancées
    $0 -d corp.local -u user@corp.local -p Pass123! -s 192.168.1.10 --ldaps -o data.json

Collection Methods:
    All       - Collecte toutes les données (par défaut)
    DCOnly    - Collecte uniquement depuis le DC (pas de sessions)
    Session   - Collecte uniquement les sessions
    Trusts    - Collecte uniquement les trusts
    ACL       - Collecte uniquement les ACLs
    Group     - Collecte uniquement les appartenances aux groupes

EOF
}

parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -d|--domain)
                DOMAIN="$2"
                shift 2
                ;;
            -u|--user)
                USERNAME="$2"
                shift 2
                ;;
            -p|--password)
                PASSWORD="$2"
                shift 2
                ;;
            -s|--server)
                LDAP_SERVER="$2"
                shift 2
                ;;
            -o|--output)
                OUTPUT_FILE="$2"
                shift 2
                ;;
            -c|--collection)
                COLLECTION_METHOD="$2"
                shift 2
                ;;
            --port)
                LDAP_PORT="$2"
                shift 2
                ;;
            --ldaps)
                USE_LDAPS=true
                LDAP_PORT="636"
                shift
                ;;
            --zip-only)
                ZIP_ONLY=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                export LDAP_VERBOSE=true
                shift
                ;;
            --no-tls)
                USE_LDAPS=false
                shift
                ;;
            -h|--help)
                show_usage
                exit 0
                ;;
            *)
                echo "[$(date '+%Y-%m-%dT%H:%M:%S')] ERROR: Option inconnue: $1" >&2
                show_usage
                exit 1
                ;;
        esac
    done
    
    if [ -z "$DOMAIN" ] || [ -z "$USERNAME" ] || [ -z "$PASSWORD" ] || [ -z "$LDAP_SERVER" ]; then
        echo "[$(date '+%Y-%m-%dT%H:%M:%S')] ERROR: Tous les paramètres obligatoires doivent être fournis" >&2
        show_usage
        exit 1
    fi
    
    if [ -z "$OUTPUT_FILE" ]; then
        OUTPUT_FILE="bloodhound_$(date +%Y%m%d_%H%M%S).json"
    fi
}

################################################################################
# Display the BashHound-CE ASCII banner with colors
# Uses 24-bit RGB colors for modern terminal support
################################################################################
show_banner() {
    local bashhound_color='\033[38;2;0;229;142m'  # Cyan/green
    local ce_color='\033[38;2;255;165;0m'         # Orange
    local author_color='\033[38;2;207;51;246m'    # Purple
    local reset='\033[0m'
    
    echo -e "${bashhound_color}    ____             __    __  __                      __${reset}     ${ce_color}____________${reset}"
    echo -e "${bashhound_color}   / __ )____ ______/ /_  / / / /___  __  ______  ____/ /${reset}    ${ce_color}/ ____/ ____/${reset}"
    echo -e "${bashhound_color}  / __  / __ \`/ ___/ __ \/ /_/ / __ \/ / / / __ \/ __  /${reset}____${ce_color}/ /   / __/${reset}"
    echo -e "${bashhound_color} / /_/ / /_/ (__  ) / / / __  / /_/ / /_/ / / / / /_/ /${reset}____${ce_color}/ /___/ /___${reset}"
    echo -e "${bashhound_color}/_____/\__,_/____/_/ /_/_/ /_/\____/\__,_/_/ /_/\__,_/${reset}     ${ce_color}\____/_____/${reset}"
    echo -e ""
    echo -e "${bashhound_color}BloodHound${reset} ${ce_color}Community Edition${reset} collector in pure Bash - by ${author_color}0xbbuddha${reset}"
    echo ""
}

################################################################################
# Main execution function
# Orchestrates the entire collection process:
# 1. Display banner and parse arguments
# 2. Connect to LDAP server with optional TLS
# 3. Authenticate with provided credentials
# 4. Collect AD data based on collection method
# 5. Export data to BloodHound CE compatible JSON
# 6. Create ZIP archive
################################################################################
main() {
    show_banner
    
    # Parse command-line arguments and validate required parameters
    parse_arguments "$@"
    
    # Auto-enable LDAPS if port 636 is specified
    if [ "$LDAP_PORT" = "636" ] && [ "$USE_LDAPS" = "false" ]; then
        USE_LDAPS=true
    fi
    
    # Determine protocol for display
    local protocol="LDAP"
    if [ "$USE_LDAPS" = "true" ]; then
        protocol="LDAPS (TLS)"
    fi
    
    # Display configuration
    echo "[$(date '+%Y-%m-%dT%H:%M:%S')] Verbosity level: $([ "$VERBOSE" = "true" ] && echo "Debug" || echo "Info")"
    echo "[$(date '+%Y-%m-%dT%H:%M:%S')] Connecting to $DOMAIN Active Directory..."
    
    # Prepare TLS flag for ldap_connect
    local use_tls="false"
    if [ "$USE_LDAPS" = "true" ]; then
        use_tls="true"
    fi
    
    # Establish LDAP connection (with or without TLS)
    # Filter output based on verbosity level
    if [ "$VERBOSE" = "true" ]; then
        ldap_connect "$LDAP_SERVER" "$LDAP_PORT" "$use_tls"
    else
        # Suppress INFO/DEBUG messages in non-verbose mode
        local tmplog="/tmp/bashhound_log_$$"
        ldap_connect "$LDAP_SERVER" "$LDAP_PORT" "$use_tls" 2>"$tmplog"
        grep -vE "INFO:|DEBUG:" "$tmplog" >&2 2>/dev/null || true
        rm -f "$tmplog"
    fi
    
    # Verify connection was successful
    if [ -z "$LDAP_FD" ] || [ "$LDAP_FD" = "" ]; then
        echo "[$(date '+%Y-%m-%dT%H:%M:%S')] ERROR: Impossible de se connecter au serveur LDAP" >&2
        exit 1
    fi
    
    # Prepare bind DN - convert username to proper LDAP DN format if needed
    # Supports: username, user@domain.com, or full DN (CN=...)
    local bind_dn="$USERNAME"
    
    if [[ ! "$bind_dn" =~ @ ]] && [[ ! "$bind_dn" =~ ^CN= ]]; then
        # Simple username -> Convert to CN=user,CN=Users,DC=domain,DC=local
        bind_dn="CN=$USERNAME,CN=Users,$(echo "$DOMAIN" | sed 's/\./,DC=/g' | sed 's/^/DC=/')"
    fi
    
    # Authenticate to LDAP server
    if [ "$VERBOSE" = "true" ]; then
        ldap_bind "$bind_dn" "$PASSWORD"
    else
        local tmplog="/tmp/bashhound_log_$$"
        ldap_bind "$bind_dn" "$PASSWORD" 2>"$tmplog"
        grep -vE "INFO:|DEBUG:" "$tmplog" >&2 2>/dev/null || true
        rm -f "$tmplog"
    fi
    
    # Check authentication result
    if [ $? -ne 0 ]; then
        echo "[$(date '+%Y-%m-%dT%H:%M:%S')] ERROR: Authentication failed" >&2
        ldap_disconnect
        exit 1
    fi
    
    echo "[$(date '+%Y-%m-%dT%H:%M:%S')] Connected to $DOMAIN Active Directory!"
    echo "[$(date '+%Y-%m-%dT%H:%M:%S')] Starting data collection..."
    
    local raw_data=""
    
    # -------------------------------------------------------------------------
    # DATA COLLECTION PHASE
    # Execute collection functions based on selected collection method
    # Each collector queries LDAP and stores results in temporary files
    # The '|| true' ensures script continues even if individual queries fail
    # -------------------------------------------------------------------------
    case "$COLLECTION_METHOD" in
        # All: Complete collection (default)
        # Collects: domain, users, groups, computers, GPOs, OUs, containers, trusts, AD CS
        All|all|ALL)
            if [ "$VERBOSE" = "true" ]; then
                collector_init_domain "$DOMAIN" 2>&1
                collect_domain_info 2>&1 || true
                collect_users 2>&1 || true
                collect_groups 2>&1 || true
                collect_computers 2>&1 || true
                collect_gpos 2>&1 || true
                collect_ous 2>&1 || true
                collect_containers 2>&1 || true
                collect_trusts 2>&1 || true
                collect_cert_templates 2>&1 || true
                collect_enterprise_cas 2>&1 || true
            else
                collector_init_domain "$DOMAIN" >/dev/null 2>&1 || true
                collect_domain_info >/dev/null 2>&1 || true
                collect_users >/dev/null 2>&1 || true
                collect_groups >/dev/null 2>&1 || true
                collect_computers >/dev/null 2>&1 || true
                collect_gpos >/dev/null 2>&1 || true
                collect_ous >/dev/null 2>&1 || true
                collect_containers >/dev/null 2>&1 || true
                collect_trusts >/dev/null 2>&1 || true
                collect_cert_templates >/dev/null 2>&1 || true
                collect_enterprise_cas >/dev/null 2>&1 || true
            fi
            ;;
        # DCOnly: Same as All but designed for DC-only enumeration
        # No difference in current implementation (sessions not implemented)
        DCOnly|dconly)
            if [ "$VERBOSE" = "true" ]; then
                collector_init_domain "$DOMAIN" 2>&1
                collect_domain_info 2>&1 || true
                collect_users 2>&1 || true
                collect_groups 2>&1 || true
                collect_computers 2>&1 || true
                collect_gpos 2>&1 || true
                collect_ous 2>&1 || true
                collect_containers 2>&1 || true
                collect_trusts 2>&1 || true
                collect_cert_templates 2>&1 || true
                collect_enterprise_cas 2>&1 || true
            else
                collector_init_domain "$DOMAIN" >/dev/null 2>&1 || true
                collect_domain_info >/dev/null 2>&1 || true
                collect_users >/dev/null 2>&1 || true
                collect_groups >/dev/null 2>&1 || true
                collect_computers >/dev/null 2>&1 || true
                collect_gpos >/dev/null 2>&1 || true
                collect_ous >/dev/null 2>&1 || true
                collect_containers >/dev/null 2>&1 || true
                collect_trusts >/dev/null 2>&1 || true
                collect_cert_templates >/dev/null 2>&1 || true
                collect_enterprise_cas >/dev/null 2>&1 || true
            fi
            ;;
        # Trusts: Collect only domain trust relationships
        Trusts|trusts)
            if [ "$VERBOSE" = "true" ]; then
                collector_init_domain "$DOMAIN" 2>&1
                collect_trusts 2>&1 || true
            else
                collector_init_domain "$DOMAIN" >/dev/null 2>&1 || true
                collect_trusts >/dev/null 2>&1 || true
            fi
            ;;
        # Unknown method: fallback to minimal collection
        *)
            echo "[$(date '+%Y-%m-%dT%H:%M:%S')] WARN: Méthode de collection inconnue, utilisation de 'All'" >&2
            if [ "$VERBOSE" = "true" ]; then
                collector_init_domain "$DOMAIN" 2>&1
                collect_users 2>&1 || true
            else
                collector_init_domain "$DOMAIN" >/dev/null 2>&1 || true
                collect_users >/dev/null 2>&1 || true
            fi
            ;;
    esac
    
    echo "[$(date '+%Y-%m-%dT%H:%M:%S')] All data collected for NamingContext DC=$(echo "$DOMAIN" | tr '.' ',DC=')"
    
    # Close LDAP connection - data collection is complete
    ldap_unbind 2>&1 | grep -v "INFO:" >&2
    
    # -------------------------------------------------------------------------
    # EXPORT PHASE
    # Parse collected data from temporary files and export to BloodHound CE
    # compatible JSON files (v6 format)
    # -------------------------------------------------------------------------
    echo "[$(date '+%Y-%m-%dT%H:%M:%S')] Starting the LDAP objects parsing..."
    
    local output_prefix="bloodhound"
    # export_create_json_files returns list of created files
    local created_files=($(export_create_json_files "$DOMAIN" "$output_prefix" 2>&1 | grep -v "INFO:"))
    
    # -------------------------------------------------------------------------
    # COUNT EXPORTED OBJECTS
    # Extract count from metadata in each JSON file for summary display
    # Using specific files from created_files to avoid counting old files
    # -------------------------------------------------------------------------
    # Extract counts from the newly created files only
    local users_file=$(printf '%s\n' "${created_files[@]}" | grep 'bloodhound_users_' | head -1)
    local groups_file=$(printf '%s\n' "${created_files[@]}" | grep 'bloodhound_groups_' | head -1)
    local computers_file=$(printf '%s\n' "${created_files[@]}" | grep 'bloodhound_computers_' | head -1)
    local domains_file=$(printf '%s\n' "${created_files[@]}" | grep 'bloodhound_domains_' | head -1)
    local gpos_file=$(printf '%s\n' "${created_files[@]}" | grep 'bloodhound_gpos_' | head -1)
    local ous_file=$(printf '%s\n' "${created_files[@]}" | grep 'bloodhound_ous_' | head -1)
    local containers_file=$(printf '%s\n' "${created_files[@]}" | grep 'bloodhound_containers_' | head -1)
    
    local users_count=$([ -f "$users_file" ] && jq '.meta.count' "$users_file" 2>/dev/null || echo 0)
    local groups_count=$([ -f "$groups_file" ] && jq '.meta.count' "$groups_file" 2>/dev/null || echo 0)
    local computers_count=$([ -f "$computers_file" ] && jq '.meta.count' "$computers_file" 2>/dev/null || echo 0)
    local domains_count=$([ -f "$domains_file" ] && jq '.meta.count' "$domains_file" 2>/dev/null || echo 0)
    local gpos_count=$([ -f "$gpos_file" ] && jq '.meta.count' "$gpos_file" 2>/dev/null || echo 0)
    local ous_count=$([ -f "$ous_file" ] && jq '.meta.count' "$ous_file" 2>/dev/null || echo 0)
    local containers_count=$([ -f "$containers_file" ] && jq '.meta.count' "$containers_file" 2>/dev/null || echo 0)
    
    echo "[$(date '+%Y-%m-%dT%H:%M:%S')] Parsing LDAP objects finished!"
    
    # -------------------------------------------------------------------------
    # CREATE ZIP ARCHIVE
    # Package all JSON files into a single ZIP for easy upload to BloodHound
    # -------------------------------------------------------------------------
    if [ ${#created_files[@]} -gt 0 ]; then
        local timestamp=$(date +%Y%m%d_%H%M%S)
        local domain_clean=$(echo "$DOMAIN" | tr '[:upper:]' '[:lower:]' | tr '.' '-')
        local zip_filename="${timestamp}_${domain_clean}_bashhound.zip"
        if command -v zip >/dev/null 2>&1; then
            zip -q "$zip_filename" "${created_files[@]}" 2>/dev/null
            if [ $? -eq 0 ]; then
                local bashhound_color='\033[38;2;0;229;142m'
                local reset='\033[0m'
                echo "[$(date '+%Y-%m-%dT%H:%M:%S')] $users_count users parsed!"
                echo "[$(date '+%Y-%m-%dT%H:%M:%S')] $groups_count groups parsed!"
                echo "[$(date '+%Y-%m-%dT%H:%M:%S')] $computers_count computers parsed!"
                echo "[$(date '+%Y-%m-%dT%H:%M:%S')] $ous_count ous parsed!"
                echo "[$(date '+%Y-%m-%dT%H:%M:%S')] $domains_count domains parsed!"
                echo "[$(date '+%Y-%m-%dT%H:%M:%S')] $gpos_count gpos parsed!"
                echo "[$(date '+%Y-%m-%dT%H:%M:%S')] $containers_count containers parsed!"
                
                # Count trusts only from the newly created domain file
                if [ -f "$domains_file" ]; then
                    local trusts_count=$(jq '[.data[].Trusts | length] | add // 0' "$domains_file" 2>/dev/null || echo 0)
                    if [ "$trusts_count" != "null" ] && [ "$trusts_count" -gt 0 ] 2>/dev/null; then
                        echo "[$(date '+%Y-%m-%dT%H:%M:%S')] $trusts_count domain trust(s) found!"
                    fi
                fi
                
                echo "[$(date '+%Y-%m-%dT%H:%M:%S')] $zip_filename created!"
                echo ""
                echo -e "${bashhound_color}BashHound-CE${reset} Enumeration Completed at $(date '+%H:%M:%S on %m/%d/%y')! Happy Graphing!"
                
                # Cleanup temporary collection files
                rm -f "/tmp/bashhound_users_$$" "/tmp/bashhound_groups_$$" "/tmp/bashhound_computers_$$" \
                      "/tmp/bashhound_domains_$$" "/tmp/bashhound_gpos_$$" "/tmp/bashhound_ous_$$" \
                      "/tmp/bashhound_containers_$$" "/tmp/bashhound_trusts_$$" "/tmp/bashhound_aces_$$" \
                      "/tmp/bashhound_certtemplates_$$" "/tmp/bashhound_enterprisecas_$$" 2>/dev/null
                
                if [ "$ZIP_ONLY" = "true" ]; then
                    rm -f "${created_files[@]}"
                fi
            else
                echo "[!] WARN: Échec de la création du ZIP, fichiers JSON conservés" >&2
                for file in "${created_files[@]}"; do
                    local file_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
                    echo "      - $file ($file_size octets)"
                done
            fi
        else
            echo "[!] WARN: 'zip' non trouvé, fichiers JSON individuels conservés" >&2
            echo "═══════════════════════════════════════════════════════════"
            echo "[+] Collecte terminée avec succès !"
            echo "    Fichiers créés :"
            for file in "${created_files[@]}"; do
                local file_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
                echo "      - $file ($file_size octets)"
            done
            echo "═══════════════════════════════════════════════════════════"
            echo ""
            echo "Vous pouvez maintenant importer ces fichiers dans BloodHound."
            echo "Installez 'zip' pour créer automatiquement une archive."
        fi
    else
        echo "[!] WARN: Aucune donnée collectée" >&2
        echo "═══════════════════════════════════════════════════════════"
    fi
}

if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
    main "$@"
fi


