#!/usr/bin/env bash

################################################################################
# BashHound-CE - by 0xbbuddha
# 
# Active Directory data collector for BloodHound Community Edition (v6)
# Written in pure Bash - Alternative to SharpHound and RustHound
#
# This tool collects AD data via LDAP/LDAPS and exports it in BloodHound CE
# compatible JSON format. No external dependencies except standard Unix tools.
################################################################################

# Error handling disabled to allow the script to continue on LDAP errors
# Some LDAP queries may fail without breaking the entire collection
# set -euo pipefail
# set -u

# Script initialization - determine script location and load libraries
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Detect installed package version from system package manager
get_package_version() {
    local version=""
    
    # Try Arch Linux / pacman (AUR packages like bashhound-ce-git)
    if command -v pacman &>/dev/null; then
        version=$(pacman -Q bashhound-ce-git 2>/dev/null | awk '{print $2}')
        [ -z "$version" ] && version=$(pacman -Q bashhound-ce 2>/dev/null | awk '{print $2}')
    fi
    
    # Try Debian/Ubuntu / dpkg
    if [ -z "$version" ] && command -v dpkg &>/dev/null; then
        version=$(dpkg -l bashhound-ce 2>/dev/null | grep '^ii' | awk '{print $3}')
        [ -z "$version" ] && version=$(dpkg -l bashhound-ce-git 2>/dev/null | grep '^ii' | awk '{print $3}')
    fi
    
    # Try RPM-based (RedHat/Fedora/CentOS)
    if [ -z "$version" ] && command -v rpm &>/dev/null; then
        version=$(rpm -q bashhound-ce 2>/dev/null | sed 's/bashhound-ce-//')
        [ -z "$version" ] && version=$(rpm -q bashhound-ce-git 2>/dev/null | sed 's/bashhound-ce-git-//')
    fi
    
    # Fallback to "dev" if not installed as package
    if [ -z "$version" ] || [[ "$version" =~ "not installed" ]]; then
        version="dev"
    fi
    
    echo "$version"
}

VERSION=$(get_package_version)
source "$SCRIPT_DIR/lib/ldap.sh"        # Core LDAP protocol implementation
source "$SCRIPT_DIR/lib/collectors.sh"  # AD object collectors (users, groups, etc.)
source "$SCRIPT_DIR/lib/export_ce.sh"   # BloodHound CE JSON export functions

# Global configuration variables
DOMAIN=""                  # Target AD domain (e.g., domain.local)
USERNAME=""                # Authentication username
PASSWORD=""                # Authentication password
LDAP_SERVER=""             # DC/LDAP server address
LDAP_PORT="389"            # LDAP port (389 for plain, 636 for TLS)
USE_LDAPS=false            # Whether to use LDAPS (TLS encryption)
OUTPUT_FILE=""             # Custom output filename (optional)
COLLECTION_METHOD="All"    # Collection method (All, DCOnly, Session, etc.)
ZIP_ONLY=false             # Delete JSON files after creating ZIP
VERBOSE=false              # Enable verbose/debug output

# Logging functions for consistent output formatting
log_info() {
    local module="$1"
    local message="$2"
    echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ') INFO  bashhound_ce::${module}] ${message}"
}

log_warn() {
    local module="$1"
    local message="$2"
    echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ') WARN  bashhound_ce::${module}] ${message}" >&2
}

log_error() {
    local module="$1"
    local message="$2"
    echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ') ERROR bashhound_ce::${module}] ${message}" >&2
}

show_banner() {
    local timestamp=$(date '+%H:%M:%S on %m/%d/%y')
    echo "---------------------------------------------------"
    echo "Initializing BashHound-CE at ${timestamp}"
    echo "Powered by @0xbbuddha"
    echo "---------------------------------------------------"
    echo ""
}

show_usage() {
    cat <<EOF
BashHound-CE - BloodHound Community Edition collector in pure Bash

Usage: $0 [options]

Mandatory options:
    -d, --domain DOMAIN          Domain Active Directory (example: domain.local)

Optional options:
    -u, --ldapuser USERNAME          Username
    -p, --ldappassword PASSWORD      Password user
    -f, --ldapfqdn FQDN          LDAP server / Domain Controller
    -o, --output FILE            Output file (default: bloodhound_TIMESTAMP.json)
    -c, --collection METHOD      Collection method (default: All)
                                 Values: All, DCOnly, Session, LoggedOn, Trusts, ACL, Group
    --zip-only                   Delete JSON files after creating the ZIP
    --port PORT                  LDAP port (default: 389 for LDAP, 636 for LDAPS)
    --ldaps                      Use LDAPS (TLS) - equivalent to --port 636
    --no-tls                     Force LDAP without TLS even on port 636
    -v, --verbose                Verbose mode (display all messages)
    -V, --version                Display version information
    -h, --help                   Display this help

Collection Methods:
    All       - Collect all data (default)
    DCOnly    - Collect only from the DC (no sessions)
    Session   - Collect only sessions
    Trusts    - Collect only trusts
    ACL       - Collect only ACLs
    Group     - Collect only group memberships

EOF
}

parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -d|--domain)
                DOMAIN="$2"
                shift 2
                ;;
            -u|--ldapuser)
                USERNAME="$2"
                shift 2
                ;;
            -p|--ldappassword)
                PASSWORD="$2"
                shift 2
                ;;
            -f|--ldapfqdn)
                LDAP_SERVER="$2"
                shift 2
                ;;
            -o|--output)
                OUTPUT_FILE="$2"
                shift 2
                ;;
            -c|--collection)
                COLLECTION_METHOD="$2"
                shift 2
                ;;
            --port)
                LDAP_PORT="$2"
                shift 2
                ;;
            --ldaps)
                USE_LDAPS=true
                LDAP_PORT="636"
                shift
                ;;
            --zip-only)
                ZIP_ONLY=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                export LDAP_VERBOSE=true
                shift
                ;;
            --no-tls)
                USE_LDAPS=false
                shift
                ;;
            -V|--version)
                echo "BashHound-CE version $VERSION"
                echo "by @0xbbuddha"
                exit 0
                ;;
            -h|--help)
                show_usage
                exit 0
                ;;
            *)
                log_error "main" "Unknown option: $1"
                show_usage
                exit 1
                ;;
        esac
    done
    
    if [ -z "$DOMAIN" ]; then
        echo "" >&2
        log_error "main" "The -d (domain) parameter is required"
        echo "" >&2
        echo "For more information, use '--help'." >&2
        exit 1
    fi
    
    if [ -z "$OUTPUT_FILE" ]; then
        OUTPUT_FILE="bloodhound_$(date +%Y%m%d_%H%M%S).json"
    fi
}

################################################################################
# Display the BashHound-CE ASCII banner with colors (non-verbose mode)
# Uses 24-bit RGB colors for modern terminal support
################################################################################
show_ascii_banner() {
    local bashhound_color='\033[38;2;0;229;142m'  # Cyan/green
    local ce_color='\033[38;2;255;165;0m'         # Orange
    local author_color='\033[38;2;207;51;246m'    # Purple
    local reset='\033[0m'
    
    echo -e "${bashhound_color}    ____             __    __  __                      __${reset}     ${ce_color}____________${reset}"
    echo -e "${bashhound_color}   / __ )____ ______/ /_  / / / /___  __  ______  ____/ /${reset}    ${ce_color}/ ____/ ____/${reset}"
    echo -e "${bashhound_color}  / __  / __ \`/ ___/ __ \/ /_/ / __ \/ / / / __ \/ __  /${reset}____${ce_color}/ /   / __/${reset}"
    echo -e "${bashhound_color} / /_/ / /_/ (__  ) / / / __  / /_/ / /_/ / / / / /_/ /${reset}____${ce_color}/ /___/ /___${reset}"
    echo -e "${bashhound_color}/_____/\__,_/____/_/ /_/_/ /_/\____/\__,_/_/ /_/\__,_/${reset}     ${ce_color}\____/_____/${reset}"
    echo -e ""
    echo -e "${bashhound_color}BloodHound${reset} ${ce_color}Community Edition${reset} collector in pure Bash - by ${author_color}0xbbuddha${reset}"
    echo ""
}

################################################################################
# Main execution function
# Orchestrates the entire collection process:
# 1. Display banner and parse arguments
# 2. Connect to LDAP server with optional TLS
# 3. Authenticate with provided credentials
# 4. Collect AD data based on collection method
# 5. Export data to BloodHound CE compatible JSON
# 6. Create ZIP archive
################################################################################
main() {
    # Show ASCII banner first (always shown, even with errors)
    show_ascii_banner
    
    # Parse command-line arguments
    parse_arguments "$@"
    
    # Show simple banner in verbose mode (RustHound style)
    if [ "$VERBOSE" = "true" ]; then
        show_banner
    fi
    
    # Auto-enable LDAPS if port 636 is specified
    if [ "$LDAP_PORT" = "636" ] && [ "$USE_LDAPS" = "false" ]; then
        USE_LDAPS=true
    fi
    
    # Display verbosity level
    log_info "main" "Verbosity level: $([ "$VERBOSE" = "true" ] && echo "Debug" || echo "Info")"
    log_info "main" "Collection method: $COLLECTION_METHOD"
    
    # Auto-detect LDAP server (DC) if not provided
    if [ -z "$LDAP_SERVER" ]; then
        # Try SRV record lookup first
        LDAP_SERVER=$(host -t SRV "_ldap._tcp.$DOMAIN" 2>/dev/null | grep "has SRV record" | head -1 | awk '{print $NF}' | sed 's/\.$//')
        # Fallback to domain name if SRV lookup fails
        if [ -z "$LDAP_SERVER" ]; then
            LDAP_SERVER="$DOMAIN"
        fi
    fi
    
    # Prepare TLS flag for ldap_connect
    local use_tls="false"
    if [ "$USE_LDAPS" = "true" ]; then
        use_tls="true"
    fi
    
    # Establish LDAP connection (with or without TLS)
    # Filter output based on verbosity level
    if [ "$VERBOSE" = "true" ]; then
        ldap_connect "$LDAP_SERVER" "$LDAP_PORT" "$use_tls"
    else
        # Suppress INFO/DEBUG messages in non-verbose mode
        local tmplog="/tmp/bashhound_log_$$"
        ldap_connect "$LDAP_SERVER" "$LDAP_PORT" "$use_tls" 2>"$tmplog"
        grep -vE "INFO:|DEBUG:" "$tmplog" >&2 2>/dev/null || true
        rm -f "$tmplog"
    fi
    
    # Verify connection was successful
    if [ -z "$LDAP_FD" ] || [ "$LDAP_FD" = "" ]; then
        log_error "ldap" "Unable to connect to the LDAP server"
        exit 1
    fi
    
    # Prepare bind DN - convert username to proper LDAP DN format if needed
    # Supports: username, user@domain.com, or full DN (CN=...)
    local bind_dn="$USERNAME"
    
    if [[ ! "$bind_dn" =~ @ ]] && [[ ! "$bind_dn" =~ ^CN= ]]; then
        # Simple username -> Convert to CN=user,CN=Users,DC=domain,DC=local
        bind_dn="CN=$USERNAME,CN=Users,$(echo "$DOMAIN" | sed 's/\./,DC=/g' | sed 's/^/DC=/')"
    fi
    
    # Authenticate to LDAP server
    if [ "$VERBOSE" = "true" ]; then
        ldap_bind "$bind_dn" "$PASSWORD"
    else
        local tmplog="/tmp/bashhound_log_$$"
        ldap_bind "$bind_dn" "$PASSWORD" 2>"$tmplog"
        grep -vE "INFO:|DEBUG:" "$tmplog" >&2 2>/dev/null || true
        rm -f "$tmplog"
    fi
    
    # Check authentication result
    if [ $? -ne 0 ]; then
        log_error "ldap" "Authentication failed"
        ldap_disconnect
        exit 1
    fi
    
    local domain_upper=$(echo "$DOMAIN" | tr '[:lower:]' '[:upper:]')
    log_info "ldap" "Connected to $domain_upper Active Directory!"
    log_info "ldap" "Starting data collection..."
    log_info "ldap" "Ldap filter : (objectClass=*)"
    
    local raw_data=""
    
    # -------------------------------------------------------------------------
    # DATA COLLECTION PHASE
    # Execute collection functions based on selected collection method
    # Each collector queries LDAP and stores results in temporary files
    # The '|| true' ensures script continues even if individual queries fail
    # -------------------------------------------------------------------------
    case "$COLLECTION_METHOD" in
        # All: Complete collection (default)
        # Collects: domain, users, groups, computers, GPOs, OUs, containers, trusts, AD CS
        All|all|ALL)
            if [ "$VERBOSE" = "true" ]; then
                collector_init_domain "$DOMAIN" 2>&1
                collect_domain_info 2>&1 || true
                collect_users 2>&1 || true
                collect_groups 2>&1 || true
                collect_computers 2>&1 || true
                collect_gpos 2>&1 || true
                collect_ous 2>&1 || true
                collect_containers 2>&1 || true
                collect_trusts 2>&1 || true
                collect_cert_templates 2>&1 || true
                collect_enterprise_cas 2>&1 || true
                collect_ntauthstores 2>&1 || true
                collect_aiacas 2>&1 || true
                collect_rootcas 2>&1 || true
                collect_issuancepolicies 2>&1 || true
            else
                collector_init_domain "$DOMAIN" >/dev/null 2>&1 || true
                collect_domain_info >/dev/null 2>&1 || true
                collect_users >/dev/null 2>&1 || true
                collect_groups >/dev/null 2>&1 || true
                collect_computers >/dev/null 2>&1 || true
                collect_gpos >/dev/null 2>&1 || true
                collect_ous >/dev/null 2>&1 || true
                collect_containers >/dev/null 2>&1 || true
                collect_trusts >/dev/null 2>&1 || true
                collect_cert_templates >/dev/null 2>&1 || true
                collect_enterprise_cas >/dev/null 2>&1 || true
                collect_ntauthstores >/dev/null 2>&1 || true
                collect_aiacas >/dev/null 2>&1 || true
                collect_rootcas >/dev/null 2>&1 || true
                collect_issuancepolicies >/dev/null 2>&1 || true
            fi
            ;;
        # DCOnly: Same as All but designed for DC-only enumeration
        # No difference in current implementation (sessions not implemented)
        DCOnly|dconly)
            if [ "$VERBOSE" = "true" ]; then
                collector_init_domain "$DOMAIN" 2>&1
                collect_domain_info 2>&1 || true
                collect_users 2>&1 || true
                collect_groups 2>&1 || true
                collect_computers 2>&1 || true
                collect_gpos 2>&1 || true
                collect_ous 2>&1 || true
                collect_containers 2>&1 || true
                collect_trusts 2>&1 || true
                collect_cert_templates 2>&1 || true
                collect_enterprise_cas 2>&1 || true
                collect_ntauthstores 2>&1 || true
                collect_aiacas 2>&1 || true
                collect_rootcas 2>&1 || true
                collect_issuancepolicies 2>&1 || true
            else
                collector_init_domain "$DOMAIN" >/dev/null 2>&1 || true
                collect_domain_info >/dev/null 2>&1 || true
                collect_users >/dev/null 2>&1 || true
                collect_groups >/dev/null 2>&1 || true
                collect_computers >/dev/null 2>&1 || true
                collect_gpos >/dev/null 2>&1 || true
                collect_ous >/dev/null 2>&1 || true
                collect_containers >/dev/null 2>&1 || true
                collect_trusts >/dev/null 2>&1 || true
                collect_cert_templates >/dev/null 2>&1 || true
                collect_enterprise_cas >/dev/null 2>&1 || true
                collect_ntauthstores >/dev/null 2>&1 || true
                collect_aiacas >/dev/null 2>&1 || true
                collect_rootcas >/dev/null 2>&1 || true
                collect_issuancepolicies >/dev/null 2>&1 || true
            fi
            ;;
        # Trusts: Collect only domain trust relationships
        Trusts|trusts)
            if [ "$VERBOSE" = "true" ]; then
                collector_init_domain "$DOMAIN" 2>&1
                collect_trusts 2>&1 || true
            else
                collector_init_domain "$DOMAIN" >/dev/null 2>&1 || true
                collect_trusts >/dev/null 2>&1 || true
            fi
            ;;
        # Unknown method: fallback to minimal collection
        *)
            log_warn "main" "Unknown collection method, use of 'All'"
            if [ "$VERBOSE" = "true" ]; then
                collector_init_domain "$DOMAIN" 2>&1
                collect_users 2>&1 || true
            else
                collector_init_domain "$DOMAIN" >/dev/null 2>&1 || true
                collect_users >/dev/null 2>&1 || true
            fi
            ;;
    esac
    
    log_info "ldap" "All data collected for NamingContext DC=$(echo "$DOMAIN" | tr '.' ',DC=')"
    
    # Close LDAP connection - data collection is complete
    ldap_unbind 2>&1 | grep -v "INFO:" >&2
    
    # -------------------------------------------------------------------------
    # EXPORT PHASE
    # Parse collected data from temporary files and export to BloodHound CE
    # compatible JSON files (v6 format)
    # -------------------------------------------------------------------------
    log_info "export" "Starting the LDAP objects parsing..."
    
    local output_prefix="bloodhound"
    # export_create_json_files returns list of created files
    local created_files=($(export_create_json_files "$DOMAIN" "$output_prefix" "$VERSION" 2>&1 | grep -v "INFO:"))
    
    # -------------------------------------------------------------------------
    # COUNT EXPORTED OBJECTS
    # Extract count from metadata in each JSON file for summary display
    # Using specific files from created_files to avoid counting old files
    # -------------------------------------------------------------------------
    # Extract counts from the newly created files only
    local users_file=$(printf '%s\n' "${created_files[@]}" | grep 'bloodhound_users_' | head -1)
    local groups_file=$(printf '%s\n' "${created_files[@]}" | grep 'bloodhound_groups_' | head -1)
    local computers_file=$(printf '%s\n' "${created_files[@]}" | grep 'bloodhound_computers_' | head -1)
    local domains_file=$(printf '%s\n' "${created_files[@]}" | grep 'bloodhound_domains_' | head -1)
    local gpos_file=$(printf '%s\n' "${created_files[@]}" | grep 'bloodhound_gpos_' | head -1)
    local ous_file=$(printf '%s\n' "${created_files[@]}" | grep 'bloodhound_ous_' | head -1)
    local containers_file=$(printf '%s\n' "${created_files[@]}" | grep 'bloodhound_containers_' | head -1)
    
    local certtemplates_file=$(printf '%s\n' "${created_files[@]}" | grep 'bloodhound_certtemplates_' | head -1)
    local enterprisecas_file=$(printf '%s\n' "${created_files[@]}" | grep 'bloodhound_enterprisecas_' | head -1)
    local ntauthstores_file=$(printf '%s\n' "${created_files[@]}" | grep 'bloodhound_ntauthstores_' | head -1)
    local aiacas_file=$(printf '%s\n' "${created_files[@]}" | grep 'bloodhound_aiacas_' | head -1)
    local rootcas_file=$(printf '%s\n' "${created_files[@]}" | grep 'bloodhound_rootcas_' | head -1)
    local issuancepolicies_file=$(printf '%s\n' "${created_files[@]}" | grep 'bloodhound_issuancepolicies_' | head -1)
    
    local users_count=$([ -f "$users_file" ] && jq '.meta.count' "$users_file" 2>/dev/null || echo 0)
    local groups_count=$([ -f "$groups_file" ] && jq '.meta.count' "$groups_file" 2>/dev/null || echo 0)
    local computers_count=$([ -f "$computers_file" ] && jq '.meta.count' "$computers_file" 2>/dev/null || echo 0)
    local domains_count=$([ -f "$domains_file" ] && jq '.meta.count' "$domains_file" 2>/dev/null || echo 0)
    local gpos_count=$([ -f "$gpos_file" ] && jq '.meta.count' "$gpos_file" 2>/dev/null || echo 0)
    local ous_count=$([ -f "$ous_file" ] && jq '.meta.count' "$ous_file" 2>/dev/null || echo 0)
    local containers_count=$([ -f "$containers_file" ] && jq '.meta.count' "$containers_file" 2>/dev/null || echo 0)
    local certtemplates_count=$([ -f "$certtemplates_file" ] && jq '.meta.count' "$certtemplates_file" 2>/dev/null || echo 0)
    local enterprisecas_count=$([ -f "$enterprisecas_file" ] && jq '.meta.count' "$enterprisecas_file" 2>/dev/null || echo 0)
    local ntauthstores_count=$([ -f "$ntauthstores_file" ] && jq '.meta.count' "$ntauthstores_file" 2>/dev/null || echo 0)
    local aiacas_count=$([ -f "$aiacas_file" ] && jq '.meta.count' "$aiacas_file" 2>/dev/null || echo 0)
    local rootcas_count=$([ -f "$rootcas_file" ] && jq '.meta.count' "$rootcas_file" 2>/dev/null || echo 0)
    local issuancepolicies_count=$([ -f "$issuancepolicies_file" ] && jq '.meta.count' "$issuancepolicies_file" 2>/dev/null || echo 0)
    
    log_info "export" "Parsing LDAP objects finished!"
    
    # -------------------------------------------------------------------------
    # CREATE ZIP ARCHIVE
    # Package all JSON files into a single ZIP for easy upload to BloodHound
    # -------------------------------------------------------------------------
    if [ ${#created_files[@]} -gt 0 ]; then
        local timestamp=$(date +%Y%m%d_%H%M%S)
        local domain_clean=$(echo "$DOMAIN" | tr '[:upper:]' '[:lower:]' | tr '.' '-')
        local zip_filename="${timestamp}_${domain_clean}_bashhound.zip"
        if command -v zip >/dev/null 2>&1; then
            zip -q "$zip_filename" "${created_files[@]}" 2>/dev/null
            if [ $? -eq 0 ]; then
                log_info "export" "$users_count users parsed!"
                log_info "export" "$groups_count groups parsed!"
                log_info "export" "$computers_count computers parsed!"
                log_info "export" "$ous_count ous parsed!"
                log_info "export" "$domains_count domains parsed!"
                log_info "export" "$gpos_count gpos parsed!"
                log_info "export" "$containers_count containers parsed!"
                [ "$ntauthstores_count" -gt 0 ] && log_info "export" "$ntauthstores_count ntauthstores parsed!"
                [ "$aiacas_count" -gt 0 ] && log_info "export" "$aiacas_count aiacas parsed!"
                [ "$rootcas_count" -gt 0 ] && log_info "export" "$rootcas_count rootcas parsed!"
                [ "$enterprisecas_count" -gt 0 ] && log_info "export" "$enterprisecas_count enterprisecas parsed!"
                [ "$certtemplates_count" -gt 0 ] && log_info "export" "$certtemplates_count certtemplates parsed!"
                [ "$issuancepolicies_count" -gt 0 ] && log_info "export" "$issuancepolicies_count issuancepolicies parsed!"
                
                # Count trusts only from the newly created domain file
                if [ -f "$domains_file" ]; then
                    local trusts_count=$(jq '[.data[].Trusts | length] | add // 0' "$domains_file" 2>/dev/null || echo 0)
                    if [ "$trusts_count" != "null" ] && [ "$trusts_count" -gt 0 ] 2>/dev/null; then
                        log_info "export" "$trusts_count domain trust(s) found!"
                    fi
                fi
                
                log_info "export" "$zip_filename created!"
                echo ""
                local bashhound_color='\033[38;2;0;229;142m'
                local ce_color='\033[38;2;255;165;0m'
                local reset='\033[0m'
                echo -e "${bashhound_color}BashHound${reset}-${ce_color}CE${reset} Collection Completed at $(date '+%H:%M:%S on %m/%d/%y')! Happy Graphing!"
                
                # Cleanup temporary collection files
                rm -f "/tmp/bashhound_users_$$" "/tmp/bashhound_groups_$$" "/tmp/bashhound_computers_$$" \
                      "/tmp/bashhound_domains_$$" "/tmp/bashhound_gpos_$$" "/tmp/bashhound_ous_$$" \
                      "/tmp/bashhound_containers_$$" "/tmp/bashhound_trusts_$$" "/tmp/bashhound_aces_$$" \
                      "/tmp/bashhound_certtemplates_$$" "/tmp/bashhound_enterprisecas_$$" \
                      "/tmp/bashhound_ntauthstores_$$" "/tmp/bashhound_aiacas_$$" \
                      "/tmp/bashhound_rootcas_$$" "/tmp/bashhound_issuancepolicies_$$" 2>/dev/null
                
                if [ "$ZIP_ONLY" = "true" ]; then
                    rm -f "${created_files[@]}"
                fi
            else
                log_warn "export" "Failed to create the ZIP, JSON files remain"
                for file in "${created_files[@]}"; do
                    local file_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
                    echo "      - $file ($file_size octets)"
                done
            fi
        else
            log_warn "export" "'zip' not found, individual JSON files remain"
            echo "═══════════════════════════════════════════════════════════"
            echo "[+] Collection completed successfully!"
            echo "    Created files:"
            for file in "${created_files[@]}"; do
                local file_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
                echo "      - $file ($file_size octets)"
            done
            echo "═══════════════════════════════════════════════════════════"
            echo ""
            echo "You can now import these files into BloodHound."
            echo "Install 'zip' to automatically create a ZIP archive."
        fi
    else
        log_warn "export" "No data collected"
        echo "═══════════════════════════════════════════════════════════"
    fi
}

if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
    main "$@"
fi


